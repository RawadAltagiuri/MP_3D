function [path, cost] = searchAlgorithmRRT(sp, rrtConf)
    % For showing the tree (init).
    drawInit(sp.start_conf, sp.goal_conf, sp.home_base);

    graphTree = {sp.start_conf, 0};
    for i = 1:rrtConf.numOfNodes
        if rand(1) > rrtConf.pOfGoal
            randomConfig = randomConf(sp);
            chosenGoal = false;
        else
            randomConfig = sp.goal_conf;
            chosenGoal = true;
        end

        prevTreeSize = size(graphTree, 1);
        graphTree = updateTree(sp, rrtConf, graphTree, randomConfig);

        if chosenGoal && prevTreeSize ~= size(graphTree, 1) && ...
                getHeuristic(sp.typeOfHeuristic, graphTree{end, 1}, sp) < 1
            [path, cost] = backtractPath(sp, graphTree);
            return;
        end
    end

    prevTreeSize = size(graphTree, 1);
    graphTree = updateTree(sp, rrtConf, graphTree, sp.goal_conf);
    if chosenGoal && prevTreeSize ~= size(graphTree, 1)
        [path, cost] = backtractPath(sp, graphTree);
    else
        path = {};
        cost = -1;
    end
end

function heuristic = getHeuristicBridge(sp, conf1, conf2)
    sp.goal_conf = conf2;
    heuristic = getHeuristic(sp.typeOfHeuristic, conf1, sp);
end

function [fullPath, totalCost] = backtractPath(sp, graphTree)
    totalCost = 0;
    curNode = graphTree(end, :);
    fullPath = {};
    paths = {};
    while curNode{2} > 0
        parentNode = graphTree(curNode{2}, :);
        [path, cost] = directExpansion(parentNode{1}, curNode{1}, sp);
        paths = [paths, {path}];
        totalCost = totalCost + cost;
        curNode = parentNode;
    end
    paths = flip(paths, 2);
    for i = 1:size(paths, 2)
        fullPath = [fullPath, paths{i}];
    end
end

function graphTree = updateTree(sp, rrtConf, graphTree, randomConfig)
    closestParent = 1;
    closestDistance = getHeuristicBridge(sp, graphTree{1, 1}, randomConfig);
    for j = 2:size(graphTree, 1)
        distance = getHeuristicBridge(sp, graphTree{j, 1}, randomConfig);
        if distance < closestDistance
            closestParent = j;
            closestDistance = distance;
        end
    end

    [directPath, ~] = directExpansion(graphTree{closestParent, 1}, randomConfig, sp);
    if ~isempty(directPath)
        newNodeIndex = 0;
        for j = 1:min(size(directPath, 2), rrtConf.stepSize)
            newNodeIndex = newNodeIndex + 1;
        end
        newNode = directPath{newNodeIndex};
        graphTree = [graphTree; {newNode, closestParent}];
    end
end

function drawInit(startConfig, goalConfig, home_base)
    grayRobotColor = '#569c69';

    clf;
    hold on;
    axis equal;
    grid on;
    xlabel('x');
    ylabel('y');
    zlabel('z');
    xlim([-400 400]);
    ylim([-400 400]);
    zlim([-100 1000]);
    plot3(home_base(1),home_base(2),home_base(3),'--gs','LineWidth',2,'MarkerSize',10,'MarkerEdgeColor','b'); %draw home
    [startConf,~] = solveForwardKinematics_3D(startConfig,home_base,false);
    [goalConf,~] = solveForwardKinematics_3D(goalConfig,home_base,false);

    n_joints = size(startConfig,1);

    for i=2:1:n_joints+1
        plot3([startConf(i-1,1),startConf(i,1)],[startConf(i-1,2),startConf(i,2)],[startConf(i-1,3),startConf(i,3)],'-o','Color',grayRobotColor, 'LineWidth', 1.5);
    end
    for i=2:1:n_joints+1
        plot3([goalConf(i-1,1),goalConf(i,1)],[goalConf(i-1,2),goalConf(i,2)],[goalConf(i-1,3),goalConf(i,3)],'-o','Color',grayRobotColor, 'LineWidth', 1.5);
    end
end

function drawTree
function drawEach(config, home_base)
    n_joints = size(config, 1);
    [robot_CC,~] = solveForwardKinematics_3D(config, home_base, false); %solve the forward kinematics for a given robot configuration

    % draws the soft robot
    for i=2:1:n_joints+1
        plot3([robot_CC(i-1,1),robot_CC(i,1)],[robot_CC(i-1,2),robot_CC(i,2)],[robot_CC(i-1,3),robot_CC(i,3)],'-o','Color','r', 'LineWidth', 1.5);
    end
end

